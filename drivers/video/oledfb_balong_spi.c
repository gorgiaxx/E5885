

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/errno.h>
#include <linux/string.h>
#include <linux/mm.h>
#include <linux/vmalloc.h>
#include <linux/slab.h>
#include <linux/init.h>
#include <linux/fb.h>
#include <linux/gpio.h>
#include <linux/delay.h>
#include <linux/uaccess.h>
#include <linux/semaphore.h>
#include <linux/interrupt.h>
#include <linux/timer.h>
#include <linux/jiffies.h>
#include <linux/kthread.h>
#include <linux/platform_device.h>
#include <linux/device.h>
#include <linux/fs.h>
#include <linux/dma-mapping.h>
#include <asm/uaccess.h>
#if defined(CONFIG_HAS_EARLYSUSPEND)
#include <linux/earlysuspend.h>
#endif
#include <linux/leds.h>

#include <bsp_memmap.h>
#include <bsp_edma.h>
#include <hi_base.h>
#include <hi_syssc.h>
#include <bsp_version.h>
#include <linux/video/lcdfb_balong.h>
unsigned char PIC00[] = {
/*--  调入了一幅图像：D:\000\桌面\1.bmp  --*/
/*--  宽度x高度=128x64  --*/
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x80,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x40,
0xC0,0x40,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0xE0,0x00,0xF0,0x00,0xFC,
0x00,0x00,0x2F,0xA2,0xEF,0x00,0xC0,0x20,0xA0,0xA0,0x00,0x00,0x00,0x00,0xFE,0xC6,
0x1E,0xE6,0x1E,0xC6,0xFE,0x0A,0xFE,0xFE,0x02,0xFA,0x2A,0x2A,0x02,0xF6,0x02,0xFE,
0x00,0x00,0x98,0xC8,0xB8,0x00,0x00,0x00,0x00,0x00,0xFC,0x92,0x93,0xFF,0x92,0x92,
0xFF,0x92,0x92,0xFF,0x93,0x92,0x7C,0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x7D,0x39,
0x93,0xC7,0xCF,0xDF,0xDF,0xCF,0xC7,0x93,0x3B,0x79,0xFE,0x00,0x00,0x00,0x00,0x00,
0x00,0x78,0x78,0xFF,0x03,0xFD,0xFD,0x01,0xFD,0xFD,0x01,0xFD,0xFD,0x01,0xFD,0xFD,
0x03,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x03,0x00,0x03,0x00,0x03,
0x00,0x00,0x02,0x02,0x03,0x00,0x01,0x02,0x02,0x03,0x00,0x00,0x00,0x00,0x01,0x01,
0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x03,0x06,0x04,
0x07,0x04,0x06,0x03,0x02,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x02,0x03,
0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x02,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x03,0x03,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x02,
0x03,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x80,0xC0,0x60,0x20,0x20,0x60,0xC0,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x1F,0x3F,0x60,0x40,0x40,0x60,0x3F,0x1F,0x00,0x00,0xFF,0xFF,0x22,0x41,0x7F,
0x3E,0x00,0x00,0x3E,0x7F,0x49,0x49,0x6F,0x2E,0x00,0x00,0x7F,0x7F,0x01,0x01,0x00,
0x32,0x79,0x4D,0x45,0x7F,0x7E,0x00,0x01,0x3F,0x7F,0x41,0x00,0x3E,0x7F,0x41,0x41,
0x7F,0x3E,0x00,0x00,0x7F,0x7F,0x01,0x01,0x00,0x00,0x00,0x00,0x00,0x7F,0x7F,0x02,
0x01,0x7F,0x7E,0x00,0x00,0x32,0x79,0x4D,0x45,0x7F,0x7E,0x00,0x00,0x7F,0x7F,0x02,
0x01,0x7F,0x7F,0x02,0x01,0x7F,0x7E,0x00,0x00,0x3E,0x7F,0x49,0x49,0x6F,0x2E,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x83,0x83,0x80,0x00,0x00,
0x00,0x80,0x80,0x80,0x00,0x00,0x00,0x80,0x80,0x80,0x00,0x00,0x00,0x80,0x00,0x00,
0x00,0x00,0x00,0x80,0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x00,0x00,0x80,0x00,
0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x80,0x80,0x00,0x00,0x80,0x00,0x00,0x00,0x00,
0x00,0x00,0x80,0x80,0x80,0x80,0x00,0x00,0x80,0x80,0x80,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x13,0x24,0x24,0x24,0x1F,0x00,
0x21,0x30,0x28,0x24,0x23,0x00,0x1F,0x20,0x20,0x20,0x1F,0x00,0x00,0x3F,0x03,0x0C,
0x30,0x0C,0x03,0x3F,0x00,0x00,0x3F,0x24,0x24,0x24,0x1B,0x00,0x30,0x0E,0x01,0x00,
0x02,0x01,0x3F,0x00,0x00,0x1F,0x20,0x20,0x20,0x1F,0x00,0x3F,0x02,0x02,0x02,0x3C,
0x00,0x16,0x23,0x22,0x22,0x1C,0x00,0x21,0x30,0x28,0x24,0x23,0x00,0x00,0x3E,0x02,
0x02,0x3C,0x02,0x02,0x3C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};


#if (FEATURE_ON == MBB_DLOAD_SDUP)
#define SD_UPDATE_SUCCESS   (1)
#define SD_UPDATE_FAIL      (0)
/*--  宽度x高度=128x64  sd update success--*/
unsigned char  g_test_pass_img[] =
{
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x70,
0x70,0x00,0x70,0x70,0x70,0x00,0x77,0x77,0x77,0x00,0x77,0x77,0x77,0x00,0x77,0x77,
0x77,0x00,0x77,0x77,0x77,0x00,0x77,0x77,0x77,0x00,0x70,0x70,0x70,0x00,0x70,0x70,
0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x77,0x77,0x77,0x00,0x77,0x77,
0x77,0x00,0x77,0x77,0x77,0x00,0x77,0x77,0x77,0x00,0x77,0x77,0x77,0x00,0x77,0x77,
0x77,0x00,0x77,0x77,0x77,0x00,0x77,0x77,0x77,0x00,0x77,0x77,0x77,0x00,0x77,0x77,
0x77,0x00,0x77,0x77,0x77,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x77,0x77,0x77,0x00,0x77,0x77,0x77,0x00,0x77,0x77,
0x77,0x00,0x77,0x77,0x77,0x00,0x77,0x77,0x77,0x00,0x77,0x77,0x77,0x00,0x77,0x77,
0x77,0x00,0x77,0x77,0x77,0x00,0x77,0x77,0x77,0x00,0x07,0x07,0x07,0x00,0x70,0x70,
0x70,0x00,0x77,0x77,0x77,0x00,0x77,0x77,0x77,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x77,0x77,0x77,0x00,0x77,0x77,0x77,0x00,0x77,0x77,
0x77,0x00,0x70,0x70,0x70,0x00,0x07,0x07,0x07,0x00,0x77,0x77,0x77,0x00,0x77,0x77,
0x77,0x00,0x07,0x07,0x07,0x00,0x70,0x70,0x70,0x00,0x77,0x77,0x77,0x00,0x77,0x77,
0x77,0x00,0x77,0x77,0x77,0x00,0x77,0x77,0x77,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x77,0x77,0x77,0x00,0x77,0x77,
0x77,0x00,0x77,0x77,0x77,0x00,0x77,0x77,0x77,0x00,0x70,0x70,0x70,0x00,0x70,0x70,
0x70,0x00,0x77,0x77,0x77,0x00,0x77,0x77,0x77,0x00,0x77,0x77,0x77,0x00,0x77,0x77,
0x77,0x00,0x77,0x77,0x77,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x07,
0x07,0x00,0x07,0x07,0x07,0x00,0x77,0x77,0x77,0x00,0x77,0x77,0x77,0x00,0x77,0x77,
0x77,0x00,0x77,0x77,0x77,0x00,0x77,0x77,0x77,0x00,0x07,0x07,0x07,0x00,0x07,0x07,
0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};
/*--  宽度x高度=128x64  sd update failed--*/
unsigned char  g_test_fail_img[] =
{
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x80,
0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x80,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x00,0xB8,
0xB8,0xB8,0x00,0xB8,0xB8,0xB8,0x00,0xBB,0xBB,0xBB,0x00,0xBB,0xBB,0xBB,0x00,0xBB,
0xBB,0xBB,0x00,0xBB,0xBB,0xBB,0x00,0xBB,0xBB,0xBB,0x00,0xB8,0xB8,0xB8,0x00,0xB8,
0xB8,0xB8,0x00,0x80,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x80,0x80,0x00,0xBB,0xBB,0xBB,0x00,0xBB,
0xBB,0xBB,0x00,0x83,0x83,0x83,0x00,0x3B,0x3B,0x3B,0x00,0xBB,0xBB,0xBB,0x00,0xBB,
0xBB,0xBB,0x00,0xBB,0xBB,0xBB,0x00,0x3B,0x3B,0x3B,0x00,0x83,0x83,0x83,0x00,0xBB,
0xBB,0xBB,0x00,0xBB,0xBB,0xBB,0x00,0x80,0x80,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xBB,0xBB,0xBB,0x00,0xBB,0xBB,0xBB,0x00,0xBB,
0xBB,0xBB,0x00,0xBB,0xBB,0xBB,0x00,0xB8,0xB8,0xB8,0x00,0x83,0x83,0x83,0x00,0x3B,
0x3B,0x3B,0x00,0x83,0x83,0x83,0x00,0xB8,0xB8,0xB8,0x00,0xBB,0xBB,0xBB,0x00,0xBB,
0xBB,0xBB,0x00,0xBB,0xBB,0xBB,0x00,0xBB,0xBB,0xBB,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3B,0x3B,0x3B,0x00,0xBB,0xBB,0xBB,0x00,0xBB,
0xBB,0xBB,0x00,0xBB,0xBB,0xBB,0x00,0x3B,0x3B,0x3B,0x00,0x83,0x83,0x83,0x00,0xB8,
0xB8,0xB8,0x00,0x83,0x83,0x83,0x00,0x3B,0x3B,0x3B,0x00,0xBB,0xBB,0xBB,0x00,0xBB,
0xBB,0xBB,0x00,0xBB,0xBB,0xBB,0x00,0x3B,0x3B,0x3B,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3B,0x3B,0x3B,0x00,0xBB,
0xBB,0xBB,0x00,0x83,0x83,0x83,0x00,0xB8,0xB8,0xB8,0x00,0xBB,0xBB,0xBB,0x00,0xBB,
0xBB,0xBB,0x00,0xBB,0xBB,0xBB,0x00,0xB8,0xB8,0xB8,0x00,0x83,0x83,0x83,0x00,0xBB,
0xBB,0xBB,0x00,0x3B,0x3B,0x3B,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,
0x03,0x03,0x00,0x03,0x03,0x03,0x00,0x3B,0x3B,0x3B,0x00,0x3B,0x3B,0x3B,0x00,0x3B,
0x3B,0x3B,0x00,0x3B,0x3B,0x3B,0x00,0x3B,0x3B,0x3B,0x00,0x03,0x03,0x03,0x00,0x03,
0x03,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};
#endif

/************************************************************
*******************宏定义********************************
*************************************************************/

#define IMAGEBUFFER (LCD_WIDTH + 1)* (LCD_HIGHT + 1) /8
#define LCD_ID0 OLED_ID0_GPIO
#define LCD_ID1 OLED_ID1_GPIO

struct stlcdfb_par {
    struct platform_device *pdev;
    struct fb_info *info;
    u32 *vmem;

    u32 g_ulLcdPwrOnState;
    struct semaphore    g_screensemmux;

    #ifdef CONFIG_HAS_EARLYSUSPEND
        struct early_suspend earlysus_lcd;
    #endif
    u32 fb_imgType;
    u32 hw_refresh;
    u32 var_pixclock;
    u32 var_xres;
    u32 var_yres;
    u32 fb_page;
    struct lcd_panel_info panel_info;
    int ref_cnt;
    int lcd_backlight_registered;
    struct balong_bl bl;
    struct led_classdev led_cdev;
};

struct lcd_gpio{
    u32 lcd_bl_gpio;
    u32 lcd_id0_gpio;
    u32 lcd_id1_gpio;
    u32 lcd_rst_gpio;
    u32 lcd_cd_gpio;
};


/*初始化设备链表*/
static LIST_HEAD(device_list);
/*初始化互斥信号量*/
static DEFINE_MUTEX(device_list_lock);

#define START_PAGE 0xB0
#define END_PAGE   0xB7

struct balong_lcd_seq initseq[] =
{
        {'c',0xAE}, /*唤醒LCD*/
        {'c',0X33},

        {'c',0x40},/*设置像素格式*/
        {'c',0x81},/*65K  OR 262k selectiong  16bit control*/
#ifdef BSP_CONFIG_BOARD_E5885Ls_93a
        {'c',0xff},  /* increase oled contrast display */
        {'c',0xA0}, // modified to rotate lcd display, change 0xA1 to 0xA0
#else
        {'c',0x0c},
		{'c',0xA1},
#endif
        {'c',0xA4},
        {'c',0xA6},
        {'c',0xA8},
        {'c',0x3F},
        {'c',0xAD},
        {'c',0x8B},
        {'w', 100},
#ifdef BSP_CONFIG_BOARD_E5885Ls_93a
        {'c',0xC0},
#else
        {'c',0xC8},
#endif
        {'c',0xD3},
        {'c',0x00},
        {'c',0xD5},
        {'c',0x80},
        {'c',0xD9},
        {'c',0x1F},
        {'c',0xDA},
        {'c',0x12},
        {'c',0xDB},
        {'c',0x40},
        {'c',0xAF},
};
struct balong_lcd_seq initseq_futaba[] =
{
        {'c',0xAE}, /*Display OFF*/
        {'c',0xAD}, /*iNTERNAL IREF setting*/
        {'c',0x10},
        {'c',0x81}, /*Set Contrast Control*/
#ifdef BSP_CONFIG_BOARD_E5885Ls_93a
        {'c',0xff}, /* increase oled contrast display */
#else
        {'c',0x40},
#endif
        {'c',0xD5}, /*Set Display Clock Drive Ratio , Oscillator Frequency*/
        {'c',0x40},
        {'c',0xD9}, /*Pre-charge Period*/
        {'c',0x24},
        {'c',0xDB}, /*VCOMH Dselect Level*/
        {'c',0x20}, /*0.77*VCC(REST)*/
        {'c',0xA8}, /*Multiplex Ratio = 63+1*/
        {'c',0x3F}, /*(63+1)3F:RESET*/
        {'c',0xA4}, /*Entire Display Off : Resume to RAM content display*/
#ifdef BSP_CONFIG_BOARD_E5885Ls_93a
        {'c',0xC0}, /*COM Output Scan Direction : from COM0 to COM(N-1)*/
        {'c',0xA0}, /*Set Segment Remap(column address127>>0)*/
#else
        {'c',0xC8}, /*COM Output Scan Direction : from COM0 to COM(N-1)*/
        {'c',0xA1}, /*Set Segment Remap(column address127>>0)*/
#endif
        {'c',0x20}, /*Memory Addressing Mode: Page Addressing Mode*/
        {'c',0x00}, /*Horizontal addressing mode*/
        {'c',0x21}, /*Setup column start and end address*/
        {'c',0x00},
        {'c',0x7F},
        {'c',0x22}, /*Setup page start and end address*/
        {'c',0x00},
        {'c',0x07},
        {'c',0x20}, /*Memory Addressing Mode: Page Addressing Mode*/
        {'c',0x10}, /*page addressing mode*/
        {'c',0x8D}, /*Charge Pump Setting*/
        {'c',0x95}, /*A[2]=0b:Disable,1b:Enable Charge Pump ON A[7]A[0]:11 9.0V*/
        {'c',0xAF}, /*Display ON*/
};
struct balong_lcd_seq initseq_visionox[] =
{
    {'c',0xAE},     /*Set Display Off */

    {'c',0xd5},     /*display divide ratio/osc. freq. mode	*/
    {'c',0x80},
    {'c',0xA8},     /*multiplex ration mode:63 */
    {'c',0x3F},
    {'c',0xD3},     /*Set Display Offset    */
    {'c',0x00},
    {'c',0x40},     /*Set Display Start Line */
    {'c',0xAD},     /*DC-DC Control Mode Set */
    {'c',0x8B},     /*8A:External 8b:Built-in DC-DC is used */
    {'c',0x32},     /*Set Pump voltage value */
    {'c',0xA0},     /*Segment Remap	 */
    {'c',0xC0},     /*Sst COM Output Scan Direction	*/
    {'c',0xDA},     /*common pads hardware: alternative	*/
    {'c',0x12},
    {'c',0x81},     /*contrast control */
    {'c',0x66},
    {'c',0xD9},     /*set pre-charge period	  */
    {'c',0x13},
    {'c',0xDB},     /*VCOM deselect level mode */
    {'c',0x20},
    {'c',0xA4},     /*Set Entire Display On/Off	*/
    {'c',0xA6},     /*Set Normal Display */
    {'c',0xAF},     /*Set Display On   */
};
/************************************************************
*******************全局变量********************************
*************************************************************/
struct fb_info *g_fbinfo;
static int oled_MacID = 0;
static struct lcd_gpio g_lcd_gpio;
/************************************************************
*******************函数声明********************************
*************************************************************/

void lcd_reset(void);
void MainOLED_DispENon(void);
void MainOLED_DispENoff(void);
/************************************************************
*************************************************************/

 void balong_bl_set_intensity(struct led_classdev *led_cladev,enum led_brightness value)
{
    struct stlcdfb_par *par;

    par = container_of(led_cladev, struct stlcdfb_par, led_cdev);
    if(NULL == par)
    {
        hilcd_trace("par is null after container_of led_cdev!\n");
        return;
    }

    osl_sem_down(&(par->g_screensemmux));

    if(0 == value)
    {
        hilcd_trace("brightness is 0,bl will be closed!\n");
        MainOLED_DispENoff();
    }
    else
    {
        hilcd_trace("brightness is 0,bl will be open!\n");
        MainOLED_DispENon();
    }

    osl_sem_up(&(par->g_screensemmux));
}

struct fb_info g_fbinfo_get(void)
{
    return (struct fb_info )(*g_fbinfo);
}


int balong_lcd_toggle(struct balong_lcd_seq *seq, int sz)
{
    int count = 0;
    u8 buf[1] = {0};

    for (count = 0; count < sz; count++)
    {
        buf[0] = seq[count].value;
        if(seq[count].format == 'c')
        {
            /* command */
            lcd_cmd_transfer(buf);
        }
        else if(seq[count].format == 'd')
        {
            /* data */
            lcd_data_transfer(buf, 1);
        }
        else if(seq[count].format == 'w')
        {
            mdelay((unsigned int)(seq[count].value)); /*lint !e62 !e737*/
        }
    }
    return LCD_OK;
}

s32 lcd_vectid_get(u16 *pu16VectId)
{
        u32 u32Data1 = 0;
        u32 u32Data2 = 0;
        static bool is_init = BSP_FALSE;

        if(!pu16VectId)
        {
            hilcd_error("invalid parameter\n");
            return LCD_ERROR;
        }

        if(!is_init)
        {
            if(gpio_request(g_lcd_gpio.lcd_id0_gpio, "OLED_ID0_GPIO"))
            {
                hilcd_error("Gpio is busy!!! \n");
            }
            /* 设置GPIO为输入 */
            (void)gpio_direction_input(g_lcd_gpio.lcd_id0_gpio);

            if(gpio_request(g_lcd_gpio.lcd_id1_gpio, "OLED_ID1_GPIO"))
            {
                hilcd_error("Gpio is busy!!! \n");
            }
            (void)gpio_direction_input(g_lcd_gpio.lcd_id1_gpio);
            is_init = BSP_TRUE;
        }

        /* 获取输入值 */
        u32Data1 = gpio_get_value(g_lcd_gpio.lcd_id0_gpio);
        u32Data2 = gpio_get_value(g_lcd_gpio.lcd_id1_gpio);

    hilcd_trace("LCD_ID0 %x,LCD_ID1 %x\n",u32Data1,u32Data2);
    /* 获取 LCD 厂家ID*/
    *pu16VectId = (unsigned short)((1 & u32Data1 << 0)\
                     | ((1 & u32Data2) << 1));
    hilcd_error("\r\nlcd ID=%x\n",*pu16VectId);
    return LCD_OK;
}

void lcd_init_byid(u32 ucId)
{
    int ret = 0;
    if(LCD_ILITEK == ucId)
    {
        ret = balong_lcd_toggle(initseq, ARRAY_SIZE(initseq));
        if(ret)
        {
            hilcd_error("lcd init error\n");
        }
        return;
    }
    else if(LCD_CHIMEI == ucId)
    {
        hilcd_error("lcd FUTABA init\n");
        ret = balong_lcd_toggle(initseq_futaba, ARRAY_SIZE(initseq_futaba));
        if(ret)
        {
            hilcd_error("lcd init error\n");
        }
        return;
    }
    else if(LCD_VISIONOX == ucId)
    {
        hilcd_error("lcd VISIONOX init\n");
        ret = balong_lcd_toggle(initseq_visionox, ARRAY_SIZE(initseq_visionox));
        if(ret)
        {
            hilcd_error("lcd init error\n");
        }
        return;
    }
    else
    {
        hilcd_error("invalid lcd vector id:%d\n", ucId);
        return;
    }

}


void MainOLED_DispENon(void)
{
    u8 buf[1] = {0};
    hilcd_trace("invalid lcd MainOLED_DispENon\n");

    buf[0] = DISPLAY_ON;

    lcd_cmd_transfer(buf);
}

void MainOLED_DispENoff(void)
{
    u8 buf[1] = {0};
    hilcd_trace("invalid lcd MainOLED_DispENoff\n");

    buf[0] = DISPLAY_OFF;

    lcd_cmd_transfer(buf);
}

/*lint +e64 +e550 +e569*/
/*****************************************************************************
* 函 数 名  : Dis_ADDRESS
*
* 功能描述  :  0.96 OLED 初始化
*
* 输入参数  :
*
* 输出参数  : 无
*
* 返 回 值  :
*****************************************************************************/
void Dis_ADDRESS(void)
{
    u8 buf[2] = {0,0};

    if(LCD_CHIMEI == oled_MacID) /*futaba OLED*/
    {
        buf[0] = 0x00;
        buf[1] = 0x10;
    }
    else /*信利 OLED*/
    {
        buf[0] = 0x02;
        buf[1] = 0x10;
    }

    lcd_cmd_transfer(&buf[0]);        //SET column low address
    lcd_cmd_transfer(&buf[1]);
}


void MainOLED_DispAlloff(void)
{
    u8 i;
    u8 data[128] = {0x00};

    hilcd_error("lcd MainOLED_DispAlloff\n");
    for(i = START_PAGE;i < (END_PAGE + 1);i++)
    {
        lcd_cmd_transfer(&i);
        Dis_ADDRESS();
        lcd_data_transfer(data, 128);
    }
}

void MainOLED_Disppic(char PIC [ ])
{
    u8 i;
    int k = 0;
    unsigned long flags = 0;

    for(i = START_PAGE;i < (END_PAGE + 1);i++)
    {
        local_irq_save(flags);
        lcd_cmd_transfer(&i);
        Dis_ADDRESS();
        local_irq_restore(flags);
        lcd_data_transfer(&PIC[128*(k++)], 128);
    }
}

void do_convert(unsigned char* indata, unsigned char* outdata)
{
    int h_idx = 0, v_idx = 0, bit = 0;
    unsigned char* pindata = indata;
    unsigned char* poutdata = outdata;

    for (h_idx = 0; h_idx < 16; h_idx++)
    {
        *poutdata = 0;
        for (v_idx = 7; v_idx >= 0; v_idx--)
        {
            for (bit = 7; bit >= 0; bit--)
            {
                *poutdata |= (*(pindata + 16 * bit) & (1 << v_idx)) >> v_idx;
                if (bit != 0)
                {
                    *poutdata <<= 1;
                }
            }
            poutdata++;
        }
        pindata++;
    }
}

/*将整帧的LCD数据由横向取模转换为纵向取模*/
/*len是指输入数据的长度，单位字节。目前只支持整页数据转换，即len必须为128字节的
  整数倍，否则出错。*/
/*！！此处outdata空间有调用者保证，至少为len，否则会发生内存越界！！*/
void lcd_data_format_convert(unsigned char* indata, unsigned char* outdata, int len)
{
    /*思路是，每128字节一转；如果不是128字节的整数倍，则无法转换！！*/
    int i = 0;

    if (len % 128)
    {
        return;
    }

    for (i = 0; i < len / 128; i++)
    {
        do_convert(indata + 128 * i, outdata + 128 * i);
    }
}

/*****************************************************************************
* 函 数 名  : lcdInit
*
* 功能描述  :  LCD 初始化
*
* 输入参数  :
*
* 输出参数  : 无
*
* 返 回 值  :
*****************************************************************************/
void lcd_init(void)
{
    u16 ucId = 0;
    s32 retval = 0;

    retval = lcd_vectid_get(&ucId);
    if(retval)
    {
        return;
    }

    oled_MacID = ucId;
    hilcd_error("lcd_init:oled_MacID = %d \n", ucId);

    lcd_init_byid(ucId);
    MainOLED_DispAlloff();
}

 void lcd_pwron(struct fb_info *info)
{
    struct stlcdfb_par *par = info->par;
    /*已是上电状态，无需重新上电*/
    if (LCD_PWR_ON_STATE == par->g_ulLcdPwrOnState)
    {
        /*printk("lcd has been powered on.\n");*/
        return ;
    }
    msleep(110);/*100ms以上*/

    lcd_init();
    par->g_ulLcdPwrOnState = LCD_PWR_ON_STATE;
    return ;
}

unsigned char rbuf[IMAGEBUFFER];

void print_rbuf(int index)
{
    hilcd_error("0x%x  \n",rbuf[index]);
}

s32 lcd_refresh(struct fb_info *info)
{
    struct fb_var_screeninfo var = info->var;
    struct fb_fix_screeninfo fix = info->fix;
    u8 *buf = info->screen_base + var.yoffset * fix.line_length + var.xoffset ; /* 获取用户的数据  */

    memset(rbuf, 0x00, IMAGEBUFFER);
    lcd_data_format_convert(buf,rbuf,IMAGEBUFFER);

    MainOLED_Disppic(rbuf);/*image*/

    return LCD_OK;
}


 s32 lcd_light(struct fb_info *info)
{
    u8 buf[1]= {0};
    struct stlcdfb_par *par = info->par;

    buf[0] = DISPLAY_ON;
    osl_sem_down(&(par->g_screensemmux));
    lcd_cmd_transfer(buf);
    osl_sem_up(&(par->g_screensemmux));
    return LCD_OK;
}


 s32 lcd_sleep(struct fb_info *info)
{
    u8 buf[1] = {0};
    struct stlcdfb_par *par = (struct stlcdfb_par *)info->par;

    buf[0] = DISPLAY_OFF;
    osl_sem_down(&(par->g_screensemmux));
    lcd_cmd_transfer(buf);
    osl_sem_up(&(par->g_screensemmux));
    return LCD_OK;
}

s32 lcd_pwroff(struct fb_info *info)
{
    s32 ret = 0;
    struct stlcdfb_par *par = info->par;
    /*已是下电状态，无需重新下电*/
    if (LCD_PWR_OFF_STATE == par->g_ulLcdPwrOnState)
    {
        hilcd_error("lcd has been powered off");
        return LCD_OK;
    }
    /*关闭显示*/
    ret = lcd_sleep(info);
    if(ret)
    {
        hilcd_error("lcd sleepin error");
        return LCD_ERROR;
    }
    par->g_ulLcdPwrOnState = LCD_PWR_OFF_STATE;
    return LCD_OK;
}
 s32 stlcdfb_blank(int blank_mode,struct fb_info *fbinfo)
{
   /* struct platform_device *pdev = to_platform_device(fbinfo);*/
    switch (blank_mode)
    {
        case VESA_NO_BLANKING:/*lcd power 1;backlight power1*/
        (void)lcd_light(fbinfo);
        break;
        case VESA_VSYNC_SUSPEND:/*lcd on;backlight off/sleepin*/
        (void)lcd_sleep(fbinfo);
        break;
        case VESA_HSYNC_SUSPEND:
        case VESA_POWERDOWN:/*lcd off;backlight:off*/
        (void)lcd_pwroff(fbinfo);
        break;
        default:
        break;
    }
    return 0;
}


static u32 stlcd_fb_line_length(u32 fb_index, u32 xres, u32 bpp)
{   /* The adreno GPU hardware requires that the pitch be aligned to
32 pixels for color buffers, so for the cases where the GPU
is writing directly to fb0, the framebuffer pitch
also needs to be 32 pixel aligned */
    /*if (fb_index == 0)
       return ALIGN(xres, 32) * bpp;
    else  */
        return xres * bpp;
}

int stlcdfb_check_var(struct fb_var_screeninfo *var,
            struct fb_info *info)
{
    u32 len;
    if(var->rotate != FB_ROTATE_UR)
        return -EINVAL;
    if(var->grayscale != info->var.grayscale)
        return -EINVAL;
    switch(var->bits_per_pixel){
    case 16:
        if((var->green.offset != 5) ||
            !((var->blue.offset == 11) || (var->blue.offset == 0)) ||
            !((var->red.offset == 11) || (var->red.offset == 0)) ||/*suport RGB or BGR*/
            (var->blue.length != 5) ||
            (var->green.length != 6) ||
            (var->red.length != 5) ||/*support 565*/
            (var->blue.msb_right != 0) ||
            (var->green.msb_right != 0) ||
            (var->red.msb_right != 0) ||
            (var->transp.length != 0) ||
            (var->transp.length != 0))
            {
            return -EINVAL;
            }
        break;
    case 24:
        if ((var->blue.offset != 0) ||
            (var->green.offset != 8) ||
            (var->red.offset != 16) ||
            (var->blue.length != 8) ||
            (var->green.length != 8) ||
            (var->red.length != 8) ||
            (var->blue.msb_right != 0) ||
            (var->green.msb_right != 0) ||
            (var->red.msb_right != 0) ||
            !(((var->transp.offset == 0) &&
            (var->transp.length == 0)) ||
            ((var->transp.offset == 24) &&
            (var->transp.length == 8))))
            {
                return -EINVAL;
            }
        break;
    case 32:
        /* Figure out if the user meant RGBA or ARGB
        and verify the position of the RGB components */
        if (var->transp.offset == 24) {
            if ((var->blue.offset != 0) ||
                (var->green.offset != 8) ||
                (var->red.offset != 16))
                return -EINVAL;
            } else if (var->transp.offset == 0) {
            if ((var->blue.offset != 8) ||
                (var->green.offset != 16) ||
                (var->red.offset != 24))
                return -EINVAL;
            } else
            {
                return -EINVAL;
            }
            /* Check the common values for both RGBA and ARGB */
            if ((var->blue.length != 8) ||
                (var->green.length != 8) ||
                (var->red.length != 8) ||
                (var->transp.length != 8) ||
                (var->blue.msb_right != 0) ||
                (var->green.msb_right != 0) ||
                (var->red.msb_right != 0))
            {
                return -EINVAL;
            }
            break;
    default:
            return -EINVAL;

    }
    if ((var->xres_virtual <= 0) || (var->yres_virtual <= 0))
    {
        return -EINVAL;
    }
    len = var->xres_virtual * var->yres_virtual * (var->bits_per_pixel / 8);
    if (len > info->fix.smem_len)
    {
        return -EINVAL;
    }
    if ((var->xres == 0) || (var->yres == 0))
    {
        return -EINVAL;
    }
    /*if ((var->xres > mfd->panel_info.xres) ||
        (var->yres > mfd->panel_info.yres))
        return -EINVAL;  */
    if (var->xoffset > (var->xres_virtual - var->xres))
    {
        return -EINVAL;
    }
    if (var->yoffset > (var->yres_virtual - var->yres))
    {
        return -EINVAL;
    }
    return 0;
}

int stlcdfb_set_par(struct fb_info *info)
{
    struct stlcdfb_par *par = (struct stlcdfb_par *)(info->par);
    struct fb_var_screeninfo *var = &info->var;
    int old_imgType;
    int blank = 0;
    old_imgType = par->fb_imgType;
    switch (var->bits_per_pixel) {
        case 16:
            if (var->red.offset == 0)
            {
                par->fb_imgType = MDP_BGR_565;
            }
            else
            {
                par->fb_imgType = MDP_RGB_565;
            }
            break;
            case 24:
                if ((var->transp.offset == 0) && (var->transp.length == 0))
                {
                    par->fb_imgType = MDP_RGB_888;
                }
                else if ((var->transp.offset == 24) &&
                    (var->transp.length == 8)) {
                    par->fb_imgType = MDP_ARGB_8888;
                    info->var.bits_per_pixel = 32;
                    }
                break;
        case 32:
            if (var->transp.offset == 24)
            {
                par->fb_imgType = MDP_ARGB_8888;
            }
            else
            {
                par->fb_imgType = MDP_RGBA_8888;
            }
            break;
            default:
                return -EINVAL;
        }
    if ((par->var_pixclock != var->pixclock) ||
        (par->hw_refresh && ((par->fb_imgType != old_imgType) ||
        (par->var_pixclock != var->pixclock) ||
        (par->var_xres != var->xres) ||
        (par->var_yres != var->yres)))) {
            par->var_xres = var->xres;
            par->var_yres = var->yres;
            par->var_pixclock = var->pixclock;
            blank = 1;
            }
    par->info->fix.line_length = stlcd_fb_line_length(info->node, var->xres,
        var->bits_per_pixel / 8);
    if (blank) {
        stlcdfb_blank(VESA_POWERDOWN, info);
        lcd_pwron(info);
        }
    return 0;
}

int stlcdfb_pan_display( struct fb_var_screeninfo *var, struct fb_info *info)
{
    struct stlcdfb_par *par = info->par;
    static int is_first_dispaly = 1;

    if (var->xoffset > (info->var.xres_virtual - info->var.xres))
    {
        return -EINVAL;
    }
    if (var->yoffset > (info->var.yres_virtual - info->var.yres))
    {
        return -EINVAL;
    }
    if (info->fix.xpanstep)
    {
        info->var.xoffset =
        (var->xoffset / info->fix.xpanstep) * info->fix.xpanstep;
    }
    if (info->fix.ypanstep)
    {
        info->var.yoffset =
        (var->yoffset / info->fix.ypanstep) * info->fix.ypanstep;
    }
    else
    {
        hilcd_trace("dma function not set for panel type=%d\n") ;
    }
    if(1 == is_first_dispaly)
    {
        /*kernel 刷第一图片是初始化下oled，区别不同的厂家*/
        MainOLED_DispENoff();
        lcd_reset();
        lcd_pwron(info);
        MainOLED_DispENon();
        is_first_dispaly = 0;
    }

    osl_sem_down(&(par->g_screensemmux));
    /*delet local_irq_save,because refresh the screen during disable interrupt,lead to wifi stop*/
    lcd_refresh(info);
    osl_sem_up(&(par->g_screensemmux));

    return 0;
}

int stlcdfb_open(struct fb_info *info,int user)
{
    struct stlcdfb_par *par = (struct stlcdfb_par *)info->par;

    if(!par->ref_cnt){
            hilcd_trace("first open fb %d\n",info->node);
        }

    par->ref_cnt++;
    return LCD_OK;
}


int stlcdfb_release(struct fb_info *info,int user)
{
    struct stlcdfb_par *par = (struct stlcdfb_par *)info->par;

    if(!par->ref_cnt){
        hilcd_error("try to close unopened fb %d\n",info->node);
        return -EINVAL;
        }
    par->ref_cnt--;
    if(par->ref_cnt){
         hilcd_trace("last close fb %d\n",info->node);
        }

    return LCD_OK;
}


static struct fb_ops stlcdfb_ops = {
    .owner   = THIS_MODULE,
    .fb_open = stlcdfb_open,
    .fb_release = stlcdfb_release,
    .fb_blank   = stlcdfb_blank,
    .fb_check_var = stlcdfb_check_var,
    .fb_set_par = stlcdfb_set_par,
    .fb_pan_display = stlcdfb_pan_display,
    /*.fb_fillrect = cfb_fillrect,*/
    /*.fb_copyarea = cfb_copyarea,*/
    /*.fb_imageblit = cfb_imageblit,*/

};


void lcd_reset(void)
{
    gpio_set_value(g_lcd_gpio.lcd_rst_gpio,1);
    mdelay(10);
    gpio_set_value(g_lcd_gpio.lcd_rst_gpio,0);
    mdelay(10);
    gpio_set_value(g_lcd_gpio.lcd_rst_gpio,1);
    mdelay(50);
}

#ifdef CONFIG_HAS_EARLYSUSPEND
void lcd_suspend_early(struct early_suspend *h)
{
    hilcd_trace("lcd_suspend_early\r\n");
/*P711上EUAP通过brightness亮度节点控制OLED亮灭。启动时释放main lock此earlysuspend操作不操作*/
    //lcd_sleep(g_fbinfo);

}
void lcd_resume_late(struct early_suspend *h)
{
    hilcd_trace("lcd_resume_late\r\n");
/*P711上EUAP通过brightness亮度节点控制OLED亮灭。启动时释放main lock此earlysuspend操作不操作*/
   // lcd_light(g_fbinfo);
}
#endif

s32 stlcdfb_fill(struct fb_info *info,struct stlcdfb_par *par)
{
    struct fb_var_screeninfo *var = (struct fb_var_screeninfo *)&info->var;

    switch (par->fb_imgType) {
        case MDP_RGB_565:
            info->fix.type = FB_TYPE_PACKED_PIXELS;
            info->fix.xpanstep = 1;
            info->fix.ypanstep = 1;
            var->vmode = FB_VMODE_NONINTERLACED;
            var->blue.offset = 0;
            var->green.offset = 5;
            var->red.offset = 11;
            var->blue.length = 5;
            var->green.length = 6;
            var->red.length = 5;
            var->blue.msb_right = 0;
            var->green.msb_right = 0;
            var->red.msb_right = 0;
            var->transp.offset = 0;
            var->transp.length = 0;
            var->bits_per_pixel = 1;
        break;
        case MDP_RGB_888:
            info->fix.type = FB_TYPE_PACKED_PIXELS;
            info->fix.xpanstep = 1;
            info->fix.ypanstep = 1;
            var->vmode = FB_VMODE_NONINTERLACED;
            var->blue.offset = 0;
            var->green.offset = 8;
            var->red.offset = 16;
            var->blue.length = 8;
            var->green.length = 8;
            var->red.length = 8;
            var->blue.msb_right = 0;
            var->green.msb_right = 0;
            var->red.msb_right = 0;
            var->transp.offset = 0;
            var->transp.length = 0;
            var->bits_per_pixel = 3 * 8;
        break;
        case MDP_ARGB_8888:
            info->fix.type = FB_TYPE_PACKED_PIXELS;
            info->fix.xpanstep = 1;
            info->fix.ypanstep = 1;
            var->vmode = FB_VMODE_NONINTERLACED;
            var->blue.offset = 0;
            var->green.offset = 8;
            var->red.offset = 16;
            var->blue.length = 8;
            var->green.length = 8;
            var->red.length = 8;
            var->blue.msb_right = 0;
            var->green.msb_right = 0;
            var->red.msb_right = 0;
            var->transp.offset = 24;
            var->transp.length = 8;
            var->bits_per_pixel = 4 * 8;
            break;
        case MDP_RGBA_8888:
            info->fix.type = FB_TYPE_PACKED_PIXELS;
            info->fix.xpanstep = 1;
            info->fix.ypanstep = 1;
            var->vmode = FB_VMODE_NONINTERLACED;
            var->blue.offset = 8;
            var->green.offset = 16;
            var->red.offset = 24;
            var->blue.length = 8;
            var->green.length = 8;
            var->red.length = 8;
            var->blue.msb_right = 0;
            var->green.msb_right = 0;
            var->red.msb_right = 0;
            var->transp.offset = 0;
            var->transp.length = 8;
            var->bits_per_pixel = 4 * 8;
        break;
        case MDP_YCRYCB_H2V1:
            info->fix.type = FB_TYPE_INTERLEAVED_PLANES;
            info->fix.xpanstep = 2;
            info->fix.ypanstep = 1;
            var->vmode = FB_VMODE_NONINTERLACED;
            /* how about R/G/B offset? */
            var->blue.offset = 0;
            var->green.offset = 5;
            var->red.offset = 11;
            var->blue.length = 5;
            var->green.length = 6;
            var->red.length = 5;
            var->blue.msb_right = 0;
            var->green.msb_right = 0;
            var->red.msb_right = 0;
            var->transp.offset = 0;
            var->transp.length = 0;
            var->bits_per_pixel = 2 * 8;
        break;
        default:
            hilcd_error("stlcd_fb_init: fb %d unkown image type!\n",
                info->node);
            return LCD_ERROR;
        }
    return LCD_OK;
}
#if (FEATURE_ON == MBB_DLOAD_SDUP)
void oled_sdupgrade_show(int state)
{
    MainOLED_DispENon();
    if (state == SD_UPDATE_SUCCESS)
    {
        MainOLED_Disppic(g_test_pass_img);
    }
    else if (state == SD_UPDATE_FAIL)
    {
        MainOLED_Disppic(g_test_fail_img);
    }
    else
    {
        hilcd_error("SD update show failed!\n");
    }
}
#endif

int bsp_lcd_dts_init(struct platform_device *pdev)
{
    struct device_node *device = NULL;
    char node_name[32] = "/lcd";
    u32 reg_addr[4] = {0};
    int ret = 0;

    device = of_find_node_by_path(node_name);
    if(!device)
    {
        dev_err(&pdev->dev, "audio device node is null\n");
        return -1;
    }
    ret = of_property_read_u32_array(device, "gpio", reg_addr, 4);
    if(ret)
    {
        hilcd_error("failed to get gpio from dts!\n");
        return -1;
    }

    g_lcd_gpio.lcd_id0_gpio = reg_addr[0];
    g_lcd_gpio.lcd_id1_gpio = reg_addr[1];
    g_lcd_gpio.lcd_rst_gpio = reg_addr[2];
    g_lcd_gpio.lcd_cd_gpio = reg_addr[3];
    hilcd_error("LCD paramter read from dtsi,[lcd_id0:%d][lcd_id1:%d][lcd_rst:%d][lcd_cd:%d]",
                    g_lcd_gpio.lcd_id0_gpio ,g_lcd_gpio.lcd_id1_gpio,g_lcd_gpio.lcd_rst_gpio,g_lcd_gpio.lcd_cd_gpio);
    return 0;

}

static s32  stlcdfb_probe (struct platform_device *pdev)
{
    struct fb_info *info;
    struct stlcdfb_par *par;
    struct fb_var_screeninfo *var = NULL;
    s32 retval = -ENOMEM;
    size_t size;
    u32 phys = 0;
    int ret = 0;

    /*输入参数检查*/
    if(NULL == pdev)
    {
        return -ENOMEM;
    }

    ret = bsp_lcd_dts_init(pdev);
    if(ret)
    {
        hilcd_error("lcd get dts failed!!! \n");
        return ret;
    }

    /* 初始化总线相关信息 */
    bsp_lcd_bus_init();

    /*分配一个fb_info结构体,结构体中通用指针*par为struct stlcdfb_par结构*/
    info = framebuffer_alloc(sizeof(struct stlcdfb_par), &pdev->dev);
    if (!info)
    {
        return retval;
    }
    /*info 作为pdev的drvdata*/
    platform_set_drvdata(pdev, info);

    /*par 挂接在info->par中*/
    par = info->par;

    /*初始化屏幕互斥信号量*/
    osl_sem_init(LCD_SEM_FULL, &(par->g_screensemmux));

    par->g_ulLcdPwrOnState = LCD_PWR_OFF_STATE;

    par->fb_page = FB_NUM;
    par->fb_imgType = MDP_RGB_565;
    par->ref_cnt = 0;
    par->lcd_backlight_registered = 0;

    /*初始化fb_info结构体*/

    strcpy(info->fix.id , "STLCD");

    info->fbops = &stlcdfb_ops;

    stlcdfb_fill(info,par);


    info->flags = FBINFO_FLAG_DEFAULT | FBINFO_VIRTFB;
    var = (struct fb_var_screeninfo *)&info->var  ;
    var->xres = LCD_WIDTH + 1;
    var->yres = LCD_HIGHT + 1;
    var->xres_virtual = LCD_WIDTH + 1;
    var->yres_virtual = var->yres * par->fb_page;


    par->var_xres = var->xres;
    par->var_yres = var->yres;
    par->var_pixclock = var->pixclock;

    //info->fix.line_length = stlcd_fb_line_length(info->node, var->xres,var->bits_per_pixel/8);
    info->fix.line_length = var->xres / 8; /*  128/8=16  */

    size = info->fix.line_length * var->yres;
    par->vmem =  dma_alloc_coherent(NULL, size,(dma_addr_t *) &phys, GFP_KERNEL);
    if (!par->vmem){
        hilcd_error("unable to alloc fbmem size = %u\n",size);
        goto early_exit;
    }

    info->screen_base = (u8 __force __iomem *)(par->vmem);/*(u8 __force __iomem *)*/
    info->fix.smem_start = phys;
    info->fix.smem_len = size;  /*16* 64 = 1024  */

    info->flags = FBINFO_FLAG_DEFAULT | FBINFO_VIRTFB;


    par->led_cdev.name = "lcd-backlight";
    par->led_cdev.brightness = MAX_BACKLIGHT_BRIGNTNESS;
    par->led_cdev.brightness_set = balong_bl_set_intensity;
    par->info = info;
    par->pdev = pdev;
    g_fbinfo = info;

    retval = register_framebuffer(info);
    if (retval < 0)
    {
        goto release_mem;
    }

    if(!par->lcd_backlight_registered){
        if(led_classdev_register(&pdev->dev,&par->led_cdev))
        {
            hilcd_error("led_classdev_register failed!");
        }
        else
        {
            par->lcd_backlight_registered = 1;
        }
    }


    #ifdef CONFIG_HAS_EARLYSUSPEND
    par->earlysus_lcd.suspend = lcd_suspend_early;
    par->earlysus_lcd.resume = lcd_resume_late;
    par->earlysus_lcd.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN;
    register_early_suspend(&(par->earlysus_lcd));
    #endif

    hilcd_trace(
        "fb%d: %s frame buffer device,\n\tusing %d Byte of video memory\n",
        info->node, info->fix.id, info->fix.smem_len);

    return LCD_OK;

release_mem:
    kfree(par->vmem);
early_exit:
    platform_set_drvdata(pdev,NULL);
    framebuffer_release(info);
    osl_sema_delete(&(par->g_screensemmux));

    return retval;
}

static s32  stlcdfb_remove(struct platform_device *pdev)
{
    struct fb_info *info = platform_get_drvdata(pdev);
    struct stlcdfb_par *par = NULL ;
    if(NULL == info)
    {
        pr_err("%s %d platform_get_drvdata info is NULL\n", __func__, __LINE__);
        return -EINVAL;
    }

    par = (struct stlcdfb_par *)info->par;

    platform_set_drvdata(pdev, NULL);
    if (info) {
        unregister_framebuffer(info);
        kfree(info->screen_base);
        framebuffer_release(info);
        osl_sema_delete(&(par->g_screensemmux));
    }
    if(par->lcd_backlight_registered){
        par->lcd_backlight_registered = 0;
       // led_classdev_unregister(&par->led_cdev);

    }
    #ifdef CONFIG_HAS_EARLYSUSPEND
    unregister_early_suspend(&(par->earlysus_lcd));
    #endif
    return 0;
}

#ifdef CONFIG_PM
#define BALONG_DEV_PM_OPS NULL
#endif

#ifdef CONFIG_OF
static const struct of_device_id balong_lcd_of_match[] = {
    { .compatible = "hisilicon,lcd_balong_app", },
    {},
};
MODULE_DEVICE_TABLE(of, balong_lcd_of_match);
#endif
/*驱动注册*/
static struct platform_driver stlcdfb_driver = {
    .driver = {
    .name   = "stlcd_tft_fb",
    .owner  = THIS_MODULE,
    .pm = BALONG_DEV_PM_OPS,
    .of_match_table = of_match_ptr(balong_lcd_of_match),
    },

    .probe  = stlcdfb_probe,

    .remove = stlcdfb_remove,
};


static int __init stlcdfb_init(void)
{
    int ret = 0;
    ret = platform_driver_register(&stlcdfb_driver);
    if(ret)
    {
        hilcd_error("platform_driver_register failed");
        return ret;
    }

    return 0;
}

static void __exit stlcdfb_exit(void)
{
    platform_driver_unregister(&stlcdfb_driver);
}

module_init(stlcdfb_init);
module_exit(stlcdfb_exit);
